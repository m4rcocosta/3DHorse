\documentclass{article}
\usepackage[british]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{float}
\usepackage{floatflt}
\usepackage{hyperref}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage{lineno}
\usepackage{appendix}
\usepackage{gensymb}
\usepackage{tikz}
\usepackage{tikz-3dplot}

\lstdefinelanguage{JavaScript}{
	keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}

\lstset{
	language=JavaScript,
	backgroundcolor=\color{lightgray},
	extendedchars=true,
	basicstyle=\footnotesize\ttfamily,
	showstringspaces=false,
	showspaces=false,
	numbers=left,
	numberstyle=\footnotesize,
	numbersep=9pt,
	tabsize=2,
	breaklines=true,
	showtabs=false,
	captionpos=b
}

\begin{document}
\title{\textbf{Interactive Graphics - Final Project}
		\\ \medskip \textbf{Solar System}
		\\ \medskip \large A.Y. 2018/2019 }
\date{\today}
\author{Gianmarco Cariggi 1698481 \\ \medskip Marco Costa 1691388}
\maketitle



\section{Introduction}
For the final project of the course of Interactive Graphics we decided to make a simulator of our solar system, trying to reproduce it in the most faithful and realistic way possible, using of course assumptions and approximations to simplify its implementation.


\subsection{Requirements}
\begin{itemize}
	\item Hierarchical models
	\item Lights
	\item Textures
	\item User interaction
	\item Animation
\end{itemize}


\subsection{Environment}
The project is developed in WebGL (Web Graphics Library). It's a JavaScript API for rendering interactive 2D and 3D graphics within any compatible web browser without the use of plug-ins. It is fully integrated with other web standards, allowing GPU-accelerated usage of physics and image processing and effects as part of the web page canvas.
\newline
Click \href{https://get.webgl.org/}{here} to check if your browser supports WebGL.


\subsection{Libraries not developed by the team}
\begin{itemize}
	\item \href{https://threejs.org/}{\textbf{Three.js} (rev. 107dev)}: a cross-browser JavaScript library and Application Programming Interface (API) used to create and display animated 3D computer graphics in a web browser using \textit{WebGL}.
	\item \href{https://materializecss.com/}{\textbf{Materialize} (v. 1.0.0)}: a design language that combines the classic principles of successful design along with innovation and technology.
	\item \href{https://jquery.com/}{\textbf{jQuery} (v. 3.4.1)}: it takes a lot of common tasks that require many lines of JavaScript code to accomplish, and wraps them into methods that you can call with a single line of code. It also simplifies a lot of the complicated things from \textit{JavaScript}, like \textit{AJAX} calls and \textit{DOM} manipulation.
\end{itemize}


\subsection{Assumptions and approximations}
As is well known, the planets follow an elliptical orbit (a "flattened" circumference), and the sun occupies one of the two focuses. For simplicity of implementation and positioning of the various planets, we have approximated the orbit with a circumference, and the sun occupies  centre. \newline
\par Another important fact is that the orbit of all the planets varies continuously (for example, the orbit of the earth is not the same from one year to the next), this is because there is the gravitational influence of all the celestial bodies present in the universe (and in particular in the solar system, being closer). In the solar system, besides the sun, Jupiter has an important influence, being the biggest planet. In our simulator we do not take into account all this, the planets revolve around the sun with the same orbit (we can say that the sun is the only body that influences the gravitation of the planets). \newline
\par The last detail is the actual position of the planets. Probably they will not be located in the real position, because in our simulator this position depends on the date, and in JavaScript the function \textbf{Date.getTime()} returns the milliseconds passed from January 1, 1970 to the moment in which the function is called (for this reason by entering this date the planets would all be aligned, it is the time t$_0$ of the simulator). In theory we should set a certain initial position so as to match the real position of each planet with that in the simulator. 
We decided to approximate the initial position by consulting an online simulator of the solar system\cite{solarsystemrealpositon}, setting the date to January 1, 1970. The position of each planet is determined by the angle formed by the straight line that connects each of the planets to the sun. Taking this into account, we have added an initial angle for each planet, obtained by comparing the position assumed by the various planets in our simulator and that of TheSkyLive. Obviously this angle is a simple approximation, because as said before the planets have an elliptical orbit, while in the simulator follow a circular orbit. The more time passes, the more the position of the planets in the simulator could be different from the real one. Looking at Pluto, it is possible to notice this easily, because this planet follows the most particular orbit.
It must be noted however that every planet makes a turn around the sun in the real time of revolution and makes a turn around its axis (inclined with respect to the equatorial plane) in the real time of rotation (for example the earth takes exactly one year to make the revolution around the sun and 24 hours to make a turn on itself).



\section{Usage}
The graphic interface allows to user to interact with our projects. First of all there is a fast loader page meanwhile the browser loads all the data.\par
At the beginning camera is focused on Sun and the \textit{follow-planet} flag is enabled, then you can only move camera around the sun. In order to move in the solar system, you have to disable it through the main menu.\newline
In meanwhile a background music starts in order to create a pleasant atmosphere and to take a good travel around the solar system. If you don't like it, you can disable through the specific button at bottom right of the window.\newline
Since you disable the \textit{follow-planet}, now you can move.\newline
\textbf{Have a good trip!}


\subsection{Mouse Controls}
The mouse is very important to fully enjoy this experience, so we explain the  available mouse controls below:
\begin{itemize}
	\item \textbf{Left Click}: Normally you click button or elements in the menu. If menu is opened and click on the solar system, it will close. If you click and drag the camera orbits around the target point.
	\item \textbf{Double Left Click}: If it's done over a celestial objects (except \textit{Asteroid Belt}), it permits to select and focus the camera on it.
	\item \textbf{Right Click}: If the \textit{follow-planet} flag is disabled, you can move around the environment clicking and dragging.
	\item \textbf{Scroll Wheel}: As usual, the scroll wheel permits to zoom in or zoom out on camera's target.
	\item \textbf{Move on the object}: Moving over the planets, a pop-up window appears where there are all planet's physical data.
\end{itemize}
All the commands are possible through the using of \textit{OrbitControls} of \textit{Three.js}.


\subsection{Menu Options}\label{menuoptions:section}
The menu offers to you a lot of options to custom the animation and the aspect of solar system. It can be opened or closed simply clicking on the relative button in the top right of the screen. So let to describe all the options:
\begin{itemize}
	\item \textbf{Play / Pause Animation}: Play or pause all animations of the solar system. (Default: Play)
	\item \textbf{Rotation}: Play or pause only the rotation on the axis of planet. (Default: Play)
	\item \textbf{Revolution}: Play or pause only the revolution orbit. (Default: Play)
	\item \textbf{Trajectories}: Show / Hide the orbit trajectories. (Default: ON)
	\item \textbf{Inclined orbit}: Set / Unset the real inclination of the planet's orbit. (Default: ON)
	\item \textbf{Date}: Set a specific date to see the state of solar. system. 
	\item \textbf{Time}: Set a specific time to see the state of solar system.
	\item \textbf{Speed}: Set the speed of time flowing (and then the animation). (Default: 1.0x)
	\item \textbf{Far}: Set the far parameter of camera. (Default: 10000).
	\item \textbf{Camera}: Set the camera target planet (as double click on a planet). (Default: Sun)
	\item \textbf{Follow}: Camera follows or not the target planet. (Default: ON)
	\item \textbf{Rotate Camera}: Camera orbits around the target planet. (Default: OFF)
	\item \textbf{Earth clouds}: Show / Hide the Earth's clouds. (Default: OFF)
	\item \textbf{Asteroid Belt}: Show / Hide the asteroid belt. (Default: OFF)
	\item \textbf{Ambient light}: Turn on / off the ambient light. (Default: OFF)
	\item \textbf{Sun light}: Turn on / off the Sun light. (Default: ON)
	\item \textbf{Sun glow}: Turn on / off the Sun glow. (Default: ON)
	\item \textbf{Sun light intensity}: Set the sun light intensity (Default: 1.5)
	\item \textbf{Wallpaper}: Choose the background.
	\item \textbf{Track}: Choose the background music.
	\item \textbf{Volume}: Set the volume of track. (Default: 0.3)
\end{itemize}
\newpage



\section{Implementation}
In this section, let we how we implemented all the features in the project. We prefer to divide this section in subsection to make easier the lecture and understanding.


\subsection{Three.js basic components}
The first part is about the initialization of Three.js, in this case we create the scene and the other fundamental elements for a WebGL environment. We do this in the \textit{init} function.

\subsubsection{Scene}
The first element for Three.js environment is the \textit{scene}\cite{documentation:threejs}. It is rendered and be simply instantiate using:
\begin{lstlisting}
scene = new THREE.Scene();
\end{lstlisting}

\subsubsection{Camera and OrbitControls}
The second step is the camera, it allows to watch the scene. In our case, we use a perspective camera, with a \textit{FOV} = 45\degree, \textit{near} = 0.1 and an adapting \textit{far} to make visible the far objects\cite{documentation:threejs}.
\par Beside the camera, we use OrbitControls library that allows mouse interactions with the camera. The parameter passed to the function specify which area of the canvas is under control of \textit{OrbitControls}. We choose the container, in this way, when the menu is opened, menu area is ignored by the controller\cite{documentation:threejs}.
\begin{lstlisting}
camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, far);
camera.position.y = 45;
camera.position.z = 100;
camera.lookAt(new THREE.Vector3(0, 0, 0));
controls = new THREE.OrbitControls(camera, document.getElementById("container"));
controls.autoRotateSpeed = 1;
\end{lstlisting}

\subsubsection{Raycaster}
Raycaster is very important in our project, because we have to establish which object is "captured" by the mouse cursor for different goals as we explain later\cite{documentation:threejs}. It's sufficient an instruction:
\begin{lstlisting}
raycaster = new THREE.Raycaster();
\end{lstlisting}

\subsubsection{Renderer}
We use the standard \textit{WebGLRenderer}\cite{documentation:threejs}, enabling the antialiasing filter and using Percentage-Closer Soft Shadows (PCSS) as shadow maps filter\cite{PCSS:nvidia}.
\begin{lstlisting}
renderer = new THREE.WebGLRenderer({
antialias: true
});
renderer.setSize(window.innerWidth, window.innerHeight);
document.getElementById("container").appendChild(renderer.domElement);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
\end{lstlisting}

\subsubsection{Texture Loader}
Texture loader\cite{documentation:threejs} is used to load all textures to relative objects.
\begin{lstlisting}
textureLoader = new THREE.TextureLoader();
\end{lstlisting}


\subsection{Light}\label{light:section}
In our project, light is a fundamental element, all the objects in solar system receive the sunlight. We use two kind of light source: point light coming from the sun and an optional ambient light for a better view of the shaded parts.

\subsubsection{Point Light}\label{subsec:pointlight}
Point light represents the light Sun produces in its core using the energy released through the nuclear fusion of hydrogen atoms\cite{solarcore:wikipedia}.
\par The implementation of a point light source requires the use of Three.js library that makes it easier\cite{documentation:threejs}. The code is contained in \textit{createSun()} function:
\begin{lstlisting}
sunLight = new THREE.PointLight("rgb(255, 220, 180)", 1.5);
sunLight.castShadow = true;
sunLight.shadow.bias = 0.0001;
sunLight.shadow.mapSize.width = 2048;
sunLight.shadow.mapSize.height = 2048;
scene.add(sunLight);
\end{lstlisting}
First of all we set the colour of light and its intensity. In the next lines, instead, we put the shadow parameters (bias and map size of shadow). Finally we add the light to Three.js scene.

\subsubsection{Ambient Light}
We add the ambient light to show better the shadow areas. For this reason, you can turn off with relative switch and at the start it's off. As for the point light, also the ambient light is implemented using the specific Three.js function\cite{documentation:threejs}. The code is contained in \textit{init()} function:
\begin{lstlisting}
ambientLight = new THREE.AmbientLight(0xaaaaaa, ambientLightIntensity);
scene.add(ambientLight); // Just for few light
\end{lstlisting}
Simply, we create the ambient light and add it to the scene. The \textit{ambientLightIntensity} var is used to is used to adjust the intensity of the ambient light via the dedicated slider (it is initially set so that the ambient light is off).


\subsection{Music}\label{music:section}
Music is another very important element in our project, due to amplify the user experience. Also music can be managed through Three.js library.
\par The first step is to introduce the audio listener which allows the playback of tracks. It needs that AudioListener\cite{documentation:threejs} object is added to camera as you see below:
\begin{lstlisting}
audioListener = new THREE.AudioListener();
camera.add(audioListener);
\end{lstlisting}
\par Then, it needs to add the different track and we do this in \textit{ambientMusic()} function:
\begin{lstlisting}
for (let i = 0; i < tracks.length; i++) {
	// Create tracks and put it in global audio source array
	sounds[i] = new THREE.Audio(audioListener);
	
	audioLoader.load(tracks[i], function(buffer) {
		sounds[i].setBuffer(buffer);
		sounds[i].setLoop(true);
		sounds[i].setVolume(volume);
		// Start firts track
		if (i == 0) {
			sound = sounds[0];
			sound.play();
		}
	});
}
\end{lstlisting}
For every track, it needs to build Audio\cite{documentation:threejs} object that permits to play music, using \textit{AudioListener}. Then we bind the track with Audio object, setting volume and loop playing. Finally if it is the first track, we play it.


\subsection{Models}
The models in our project are represented by the planets, Sun, Moon and other celestial objects as Asteroid Belt and planet rings. All this object are children of THREE Group Solar System.\\
All the models and the objects are represented in a 3D space with this axis:
\\
%Representation of 3d space
\begin{tikzpicture}
	\draw [->] (0,0,0) -- (1.5,0,0) node [at end, right] {$x$};
	\draw [->] (0,0,0) -- (0,1.5,0) node [at end, left] {$y$};
	\draw [->] (0,0,0) -- (0,0,1.5) node [at end, left] {$z$};
\end{tikzpicture}
\\
Now let we see all the models in this project.

\subsubsection{Planet} 
The planet is the most common model in our project. It is a sphere and is created in \textit{createPlanet()} function. All needed data to build the planet is taken by Wikipedia articles\cite{wikipedia}.
\begin{lstlisting}
let planetGeometry = new THREE.SphereGeometry(data[Id].size, planetSegments, planetSegments);
let planetMaterial = new THREE.MeshPhongMaterial({
	map: textureLoader.load(data[Id].color) // Color texture
});
//...
celestialObjects[Id] = new THREE.Mesh(planetGeometry, planetMaterial);
//...
createOrbit(Id);
\end{lstlisting}
First of all, we need for a Geometry and Material objects to create a planet. The geometry we chosen is naturally a \textit{SphereGeometry}\cite{documentation:threejs} with as radius a proportion of its real radius. In particular we choose as Earth radius the value of 1, so to find all the other measure we have made the ratio (real planet radius)/(real Earth radius), to find "how many planet is in Earth". In this way we obtain an approximated scale.
\par Regards to material object, we choose \textit{MeshPhongMaterial}\cite{documentation:threejs}, in which we load all the possible texture. In addiction of this, if it's available we load also \textit{bump, specular} and \textit{normal} texture, all taken in this website \cite{planetpixelemporium}. More are the available textures and more the planet is realistic.
\par If the planet has got rings, (Saturn or Uranus), we also create the ring but especially a \textit{THREE Group} so that they make up a system.
We had some difficulty loading the texture of the rings, as it was not loaded radially. To solve this problem, we redefined the RingGeometry function, using the one in the \textit{THREEx.planets.js}\cite{earthcloudsradiustexture} library. This function can be found in the file \textit{helper.js}.
Finally we create its orbit trajectory through \textit{createOrbit} function.

\subsubsection{Sun}
In our implementation Sun can be associated to a planet, also if we wrote a specific function to build it (\textit{createSun()}). Indeed the building of it is very similar to a planet, the only elements that differentiate it is the light, which I have already explained in the previous \hyperref[subsec:pointlight]{section 3.4.1}, and its Corona that let we describe below:
\begin{lstlisting}
let spriteMaterial = new THREE.SpriteMaterial({
map: textureLoader.load(data[sunId].glow), // Glow texture
color: 0xffffee,
transparent: true,
blending: THREE.AdditiveBlending
});
celestialObjects[sunGlowId] = new THREE.Sprite(spriteMaterial);
celestialObjects[sunGlowId].name = "Sun Glow";
celestialObjects[sunGlowId].scale.set(70, 70, 1.0);
celestialObjects[sunId].add(celestialObjects[sunGlowId]); // This centers the glow at the sun.
\end{lstlisting}
In order to create an effect similar to an atmosphere, we used the Three.js \textit{Sprite}\cite{documentation:threejs} object. It only needs for Material, in particular for \textit{SpriteMaterial}\cite{documentation:threejs}. Thus, after scaling, we add it to sun object.
\par \textbf{N.B.} The size of the sun is not exactly to scale like the rest of the celestial objects, as its actual size is about 110 times that of the earth. By creating the exact scale size the rest of the planets would have been tiny, so we decided to simply make it bigger than Jupiter.

\subsubsection{Orbit Trajectory}
Another model in our project is the orbit trajectory of the planets and other celestial bodies. We decide to insert it to show them better to user movements of the bodies and to recognize easier which planet is, the implementation is in \textit{createOrbit()} function. 
\par In order to implement this object, we take inspiration from a question posted in Stack Overflow\cite{trajectory:stackoverflow}:
\begin{lstlisting}
let orbitGeometry = new THREE.CircleGeometry(data[Id].distance, orbitSegments);
orbitGeometry.vertices.shift(); // Remove center vertex
let orbitMaterial = new THREE.LineBasicMaterial({
	color: 0xffffff
});
orbits[Id] = new THREE.LineLoop(orbitGeometry, orbitMaterial);
\end{lstlisting}
In this case, we used \textit{CircleGeometry}\cite{documentation:threejs}, \textit{LineBasicMateria}\cite{documentation:threejs} and \textit{LineLoop}\cite{documentation:threejs} object. But the most interesting part is the instruction at \textbf{line 2} that delete the vertex at centre and so that close the circumference.

\subsubsection{Asteroid Belt}
In the implementation of the asteroid belt we have encountered many difficulties.\\
In the first version, there was the use of very small spheres, using Sphere Three.js. This choice, however, involved a great use of resources given the large number of objects to be rendered. So we decided to opt for the \textit{Points}\cite{documentation:threejs} object of Three.js. In this way there is a great limiting of resources and the ability to insert a large number of bodies. 
\par The next difficulty was in debugging an error in the code, so the question posted on Stack Overflow was very helpful\cite{asteroids:stackoverflow}. The cause is an existent issue opened in GitHub with \textit{morphAttributes} object, so simply it needs to assign to this object an empty array \{\}. Let we see the code:
\begin{lstlisting}
//...
let torusAsteroid = new THREE.Mesh(new THREE.TorusGeometry(distance, maxOffsetY, planetSegments, planetSegments), new THREE.MeshBasicMaterial({
	transparent: true,  // Make torus transparent
	opacity: 0.0        // Make torus transparent
}));
//...
for (let i = 0; i < asteroidCount; i++) {
	// Create a particle with random position
	let asteroidDistance = distance + THREE.Math.randFloat(minOffsetXZ, maxOffsetXZ);
	let angle = THREE.Math.randFloat(0, THREE.Math.degToRad(360));
	let coord = new THREE.Vector3();
	
	coord.x = Math.cos(angle) * asteroidDistance;
	coord.y = THREE.Math.randFloat(minOffsetY, maxOffsetY);
	coord.z = Math.sin(angle) * asteroidDistance;

	// Insert asteroid
	asteroidsGeometry.vertices.push(coord);
}
asteroidsGeometry.morphAttributes = {};     // Used to fix updateMorphAttribute bug
celestialObjects[asteroidBeltId] = new THREE.Points(asteroidsGeometry, new THREE.PointsMaterial({ size: asteroidSize }));
//...
\end{lstlisting}
In the first step, we implement a \textit{TorusGeometry}\cite{documentation:threejs} object that has the same size of asteroid belt, since in this way if the mouse is over it, \textit{Ray Caster} finds the asteroid belt. For this reason, the torus is invisible and has only this aim.
\par In the second part, we create every asteroid with a random position such that it is inside the torus volume, adding it as a vertex in the geometry object. Then together the \textit{PointsMaterial}\cite{documentation:threejs}, we create the final object.

\subsubsection{Rings of planet}
As far as the implementation of the planetary rings is concerned, we had some difficulties with the loading of the texture. The problem was that the texture was not loaded radially along the rings. But thanks to the solution found on GitHub\cite{earthcloudsradiustexture:github}, we were able to solve the issue, due to a problem related to the object \textit{RingGeometry}\cite{documentation:threejs}.
\begin{lstlisting}
let ringGeometry = new THREE.BufferGeometry().fromGeometry(new _RingGeometry(data[Id].ringInnerDiameter, data[Id].ringOuterDiameter, data[Id].ringSegments));
let ringMaterial = new THREE.MeshPhongMaterial({
	map: textureLoader.load(data[Id].ringColor), // Color texture
	alphaMap: textureLoader.load(data[Id].ringPattern), // Pattern texture
	side: THREE.DoubleSide,
	shadowSide: THREE.DoubleSide,
	transparent: true,
	opacity: 0.8
});
celestialObjects[data[Id].ringId] = new THREE.Mesh(ringGeometry, ringMaterial);
\end{lstlisting}
Using \textit{\_RingGeometry} we manage to load texture in radial way.
As other models, it needed to create both the geometry and the material.

\subsubsection{Earth cloud}
So we decided to add clouds to the Earth to make it more realistic. The problem we encountered was similar to the previous one for the rings of the planets, we found the solution from the same source\cite{documentation:threejs}.
\par The model used is simply a \textit{SphereGeometry}\cite{documentation:threejs}, but the difficulty was in creating the material for the sphere. In order to create the material for the model, we decided to use the auxiliary function \textit{createEarthCloudMaterial()}.
\begin{lstlisting}
let earthCloudGeometry = new THREE.SphereGeometry(data[earthId].size, planetSegments, planetSegments);
let earthCloudMaterial = createEarthCloudMaterial();
celestialObjects[earthCloudId] = new THREE.Mesh(earthCloudGeometry, earthCloudMaterial);
celestialObjects[earthCloudId].scale.set(1.02, 1.02, 1.02);
//...
\end{lstlisting}

\subsection{Earth lights}
Finally, we implemented the city lights. This is just to show how you would see the Earth at night with all the lights on, so we used the material \textit{THREE.MeshMatcapMaterial}, which allows you to see the texture regardless of the sunlight. Of course, this doesn't really happen.
\begin{lstlisting}
// Listener for turn on/off Earth lights
$("#earthLightsCheckbox").on("change", function(event) {
	if (event.target.checked) celestialObjects[earthId].material = new THREE.MeshMatcapMaterial({
		map: textureLoader.load(data[earthId].lights)
	});
	else celestialObjects[earthId].material = new THREE.MeshPhongMaterial({
		map: textureLoader.load(data[earthId].color),
		bumpMap: textureLoader.load(data[earthId].bump),
		bumpScale: data[earthId].bumpScale,
		specularMap: textureLoader.load(data[earthId].specular),
		specular: new THREE.Color("grey")map: textureLoader.load(data[earthId].color),
		bumpMap: textureLoader.load(data[earthId].bump),
		bumpScale: data[earthId].bumpScale,
		specularMap: textureLoader.load(data[earthId].specular),
		specul
	});
});
\end{lstlisting}


\subsection{Animation}
The animation of our solar system is the most important part of our project. In fact, the movement of the planets and their orbits around the sun is the effect that most affects the user and that allows the best to simulate the position of the planets as time passes.
\par All movements are allowed thanks to the \textit{render} function that allows frame after frame to render the positions of the various celestial bodies in their positions.\\
The function also allows the room managed by OrbitControls to update its position, using the \textit{controls.update()} native method\cite{documentation:threejs}. \\
We will then analyse all the animations present in our project, in order to explain how they work.\\
As far as the rotation of celestial bodies is concerned, this is dealt with by the \textit{moveplanet()} function. This function calls for each body, the function for rotation and revolution motion around their orbit centre.

\subsubsection{Rotation around own axis}
The first animation implemented was the one about the rotation of bodies around their own axis. This animation is done through the \textit{rotationMovement()} function, as below:
\begin{lstlisting}
let theta = THREE.Math.degToRad(360) * (date.getTime() / (data[Id].rotationRate * 3600000)); // Cast rotationRate in milliseconds

celestialObjects[Id].rotation.y = theta;
if (Id == earthId) celestialObjects[earthCloudId].rotation.y = theta/2;
if (data[Id].hasOwnProperty("ringId")) celestialObjects[data[Id].ringId].rotation.z = theta;
\end{lstlisting}
The theta angle for rotation therefore takes care both the speed of rotation and puts it together with the time variable to establish at what "time of day" the body is, normalizing everything.\\
Once calculated how much the body must rotate (the theta angle), the rotation is then applied and if it has rings, the geometric transformation is also applied to them.

\subsubsection{Revolution orbit}
The other important animation of the planets (and the moon) is the revolution around the sun. This animation is done through the \textit{revolutionMovement()} function, as below:
\begin{lstlisting}
// Revolution angles
let theta = (THREE.Math.degToRad(360) / (data[Id].revolutionRate * 86400000)) * date.getTime(); // theta = wt, cast revolutionRate in milliseconds
let alpha = THREE.Math.degToRad(data[Id].orbitInclination); // Inclination
let phi = THREE.Math.degToRad(data[Id].initialAngle); // Initial position

let currentId = Id;
if (data[Id].hasOwnProperty("groupId")) currentId = data[Id].groupId;
celestialObjects[currentId].position.x = -data[Id].distance * Math.cos(theta + phi); // x = -R*Cos(wt + phi) (minus for Anti-clockwise)
celestialObjects[currentId].position.y = 0; // y = 0
celestialObjects[currentId].position.z = data[Id].distance * Math.sin(theta + phi); // z = R*Sin(wt + phi)

// Inclined orbit
if (inclinedOrbit) {
	celestialObjects[currentId].position.x *= Math.cos(alpha); // x = -R*Cos(wt + phi)*Cos(alpha)
	celestialObjects[currentId].position.y = -data[Id].distance * Math.cos(theta + phi) * Math.sin(alpha); // y = -R*Cos(wt + phi)*Sin(alpha)
}
\end{lstlisting}
This animation is a bit more complex than the previous one, as it requires many more concepts of trigonometry and uniform circular motion.
As you can see, we have three angles:
\begin{itemize}
	\item $\mathbf{\theta}$ (theta), that is the angle swept by the segment that connects the planet to the sun in a given instant of time (in the uniform circular motion would be the pulsation multiplied by the instant of time, $\theta = \omega\tau$, $\omega = \frac{2\pi}{\textrm{T}}$, \textrm{T} is the orbit rate)
	\item $\mathbf{\phi}$ (phi), simply determines the initial position of each planet
	\item $\mathbf{\alpha}$ (alpha), it takes into account the inclination of the orbit
\end{itemize}
After having determined such angles, it is necessary to determine the various components (x, y, z) taking into account the fact that the planets follow a uniform circular motion. For this reason the components will be:
\begin{itemize}
	\item $\mathbf{x = -R\cos(\theta + \phi)}$
	\item $\mathbf{y = 0}$
	\item $\mathbf{z = R\sin(\theta + \phi)}$
\end{itemize}
where \textbf{R} is the distance between the planet and the sun. \newline
It's possible to notice that the component \textit{y} is zero, so the motion is simply on the plane \textit{x-z}.
If instead we take into account the inclination of the orbits, the three components will be:
\begin{itemize}
	\item $\mathbf{x = -R\cos(\theta + \phi)\cos(\alpha)}$
	\item $\mathbf{y = -R\cos(\theta + \phi)\sin(\alpha)}$
	\item $\mathbf{z = R\sin(\theta + \phi)}$
\end{itemize}
N.B. the minus indicates the anti-clockwise revolution of the planets.

\subsection{User Interactions}
The user's interactions with our simulator is as important as our project, as it is a course in interactive graphics. So we gave the user the ability to modify both the graphic aspect and interact directly with the solar system.
\par This is possible by using the various buttons on the main screen and thanks to the menu with which user can modify many aspects, as we have seen in previous \hyperref[menuoptions:section]{section 2.2}. Let's go and analyse them one by one:

\subsubsection{Audio Setting}
The first feature is the configuration of the audio. As already mentioned in \hyperref[music:section]{section 3.3}, there are several audio tracks but you can also change the volume, pause or play and finally change the audio track. All this is possible by means of listeners that act on the various html elements present.
\paragraph{Play / Pause the audio} \mbox{}\\
This is possible through the following listener:
\begin{lstlisting}
$("#music-button").on("click", function(event) {
	if (sound.isPlaying) {
		sound.pause();
		$("#music-button").html("<i class='material-icons'>volume_up</i>");
	}
	else {
		sound.play();
		$("#music-button").html("<i class='material-icons'>volume_off</i>");
	}
});
\end{lstlisting}
This listener simply calls the method \textit{pause()} or \textit{play()} of Audio object and change the icon of HTML button.
\paragraph{Volume up or down} \mbox{}\\
Also in this case there is a dedicated listener for this:
\begin{lstlisting}
$("#volumeSlider").on("input", function(event) {
	volume = parseFloat(event.target.value);
	sound.setVolume(volume);
	$("#volumeText").html("Volume: " + volume);
});
\end{lstlisting}
It modifies the volume calling method \textit{setVolume()}, passing as parameter the slider value.
\paragraph{Change track} \mbox{}
\begin{lstlisting}
$("#trackSelect").on("change", function(event) {
	let track = $("#trackSelect").val();
	sound.stop();
	sound = sounds[track];
	sound.setVolume(volume);
	sound.play();
});
\end{lstlisting}
The listener stops the current track, selects the new calling the object Audio linked to new track and plays it. 

\subsubsection{Resizing the window}
This feature is needed to resizing the canvas when you change the window dimension. 
\begin{lstlisting}
$(window).on("resize", function(){
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
});
\end{lstlisting}
It is made by a simple listener that set the new aspect ratio for camera and for render objects. In order to implement it, we have taken inspiration from here\cite{resizing:stackoverflow}.

\subsubsection{Date and time changing} 
Another important feature is about the changing of date and time. This allows to user to set a date and/or time and see the position of celestial body. This is made through the follow listeners:
\begin{lstlisting}
// Listener for modify current date
$("#setDate").on("change", function(event) {
	if (play) $("#playButton").click();
	let newDate = $("#setDate").val();
	let dateString = newDate + " " + date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds();
	date = new Date(dateString);
	setDate();
	for (let i = mercuryId; i <= moonId; i++) revolutionMovement(i);
});

// Listener for modify current time
$("#setTime").on("change", function(event) {
	if (play) $("#playButton").click();
	let newTime = $("#setTime").val();
	let dateString = getMonthName(date.getMonth()) + " " + date.getDate() + ", " + date.getFullYear() + " " + newTime + ":" + date.getSeconds();
	date = new Date(dateString);
	setDate();
	for (let i = mercuryId; i <= moonId; i++) revolutionMovement(i);
});
\end{lstlisting}
First of all, all the animations are paused, then a new date object is created with the value of the past date and time, then the \textit{setDate()} function is called, which changes the graphic panel, and finally the positions of the planets are recalculated using the \textit{revolutionMovement()} function.

\subsubsection{Camera Setting}
We have implemented a lot of feature about the camera, because in our project it has a main role.
\paragraph{Changing far parameter}\mbox{}\\
The first possibility is the changing of far parameter, due to the solar system can be very large. So the far value is very important because a too bit value can hide the farthest objects. It is implemented as a listener:
\begin{lstlisting}
// Listener for modify far value
$("#farSlider").on("input", function(event) {
	far = parseFloat(event.target.value);
	camera.far = far;
	camera.updateProjectionMatrix();
	$("#farText").html("Far: " + far);
});
\end{lstlisting}
It simply change far parameter of camera object, taking the value from HTML slider, then update the project matrix of camera, using the dedicated method. For user convenience, the value of \textit{far} is showed.
\paragraph{Focusing planet}\mbox{}\\
This is very important because substitutes the double click feature to focus a planet. It is done through an HTML selector:
\begin{lstlisting}
$("#cameraSelect").on("change", function(event) {
	let planetId = $("#cameraSelect").val();
	if (data[planetId].hasOwnProperty("groupId")) planetId = data[planetId].groupId;
	followPlanetId = planetId;
	followPlanet(followPlanetId);
	goToObject(followPlanetId);
});
\end{lstlisting}
So it changes the current \textit{followPlanetId}, enabling this feature, and then calls \textit{goToObject} function that move the camera to the target body.

\paragraph{Follow planet}\mbox{}\\
In this case, there is a possibility that the camera can follow the selected planet, it can be very useful.
\begin{lstlisting}
$("#followPlanetCheckbox").on("change", function(event) {
	if (event.target.checked) cameraFollowsPlanet = true;
	else cameraFollowsPlanet = false;
});
\end{lstlisting}
It simply change a boolean variable, that is used in \textit{render} function. Indeed, if it is true, \textit{followPlanet()} function is called and it make literally the task.
\paragraph{Rotation of camera around target object}\mbox{}\\
This is another feature of camera and permits to orbit around the target object. This simply 
\begin{lstlisting}
// Listener for rotate/not rotate the camera on the target planet
$("#rotateCameraCheckbox").on("change", function(event) {
	if (event.target.checked) controls.autoRotate = true;
	else controls.autoRotate = false;
});
\end{lstlisting}

\subsubsection{Light setting}
The light, already seen in \hyperref[light:section]{section 3.2}, can be setted through the dedicated slider and switches. Let we show the features.
\paragraph{Sunlight} \mbox{}\\
The sunlight checkbox permits to turn on or off it. It simply add or remove to scene the \textit{sunLight} Point Light object.
\begin{lstlisting}
// Listener for turn on/off sun light
$("#sunLightCheckbox").on("change", function(event) {
	if (event.target.checked) scene.add(sunLight);
	else scene.remove(sunLight);
});
\end{lstlisting}
Beside the checkbox there is also a slider to adjust the intensity of this light source, setting the \textit{intensity} parameter of \textit{sunLight} object:
\begin{lstlisting}
// Listener for modify sun light intensity value
$("#sunLightSlider").on("input", function(event) {
	let intensity = parseFloat(event.target.value);
	sunLight.intensity = intensity;
	$("#sunLightText").html("Sun light intensity: " + intensity);
});
\end{lstlisting}
\paragraph{Ambient light}\mbox{}\\
As point light, also the ambient light has the same function:
\begin{lstlisting}
// Listener for turn on/off ambient light
$("#ambientLightCheckbox").on("change", function(event) {
	if (event.target.checked) scene.add(ambientLight);
	else scene.remove(ambientLight);
});
// Listener for modify ambient light intensity value
$("#ambientLightSlider").on("input", function(event) {
	let intensity = parseFloat(event.target.value);
	ambientLight.intensity = intensity;
	$("#ambientLightText").html("Ambient light intensity: " + intensity);
});
\end{lstlisting}

\subsubsection{Animation setting}
Animation settings are the most important focus of the available user interactions. They allow you to show the orbits of revolution and rotation of celestial objects. We have developed several features that can be modified, as shown below.
\paragraph{Play / Pause Animation Button} \mbox{}\\
This button permits to play or pause all the animation that are in our project. For this reason, it is the first element is present in the menu. If it pressed, it changes the \textit{play} boolean var and changes the icon, in addiction to clicking on rotation and revolution checbox: 
\begin{lstlisting}
// Listener for play/stop animation
$("#playButton").on("click", function(event) {
	if (play) {
		play = false;
		$("#playButton").html("<i class='material-icons left'>play_circle_filled</i>Play Animation");
		if ($("#rotationCheckbox").is(":checked")) $("#rotationCheckbox").click();
		if ($("#revolutionCheckbox").is(":checked")) $("#revolutionCheckbox").click();
		$("#rotationCheckbox").attr("disabled", "true");
		$("#revolutionCheckbox").attr("disabled", "true");
	}
	else {
		play = true;
		$("#playButton").html("<i class='material-icons left'>pause_circle_filled</i>Pause Animation");
		$("#rotationCheckbox").removeAttr("disabled");
		$("#revolutionCheckbox").removeAttr("disabled");
		$("#rotationCheckbox").click();
		$("#revolutionCheckbox").click();
	}
});
\end{lstlisting}
\paragraph{Rotation and revolution checkbox}\mbox{}\\
On the contrary of play button, these checkboxes change the single possible motion. They change the single boolean variable used to enable the specific motion:
\begin{lstlisting} 
// Listener for play/stop rotation movement
$("#rotationCheckbox").on("change", function(event) {
	if (event.target.checked) playRotationMovement = true;
	else playRotationMovement= false;
});

// Listener for play/stop revolution movement
$("#revolutionCheckbox").on("change", function(event) {
	if (event.target.checked) playRevolutionMovement = true;
	else playRevolutionMovement= false;
});
\end{lstlisting}
\paragraph{Speed factor}\mbox{}\\
It used to determine the speed with which time passes. It is setted through a slider, as below:
\begin{lstlisting} 
// Listener for modify speedFactor value
$("#speedSlider").on("input", function(event) {
	speedFactor = event.target.value;
	$("#speedText").html("Speed: " + speedFactor + "x");
});
\end{lstlisting}

\subsection{Appearance Settings}
These settings concern how the user can see our simulator and the positions of the various celestial bodies. These settings have only an aesthetic function and do not affect the movements and positions of objects.
\paragraph{Orbit Setting}\mbox{}\\
The orbit object is a trajectory (approximated circumference) of the planet movement. It can be show better the position of the planet and find it between the others.\\
It's possible to show or hide the orbit and set the real inclination:
\begin{lstlisting}
// Listener for show/hide orbits
$("#orbitVisibilityCheckbox").on("change", function(event) {
	if (event.target.checked) for (let i = mercuryId; i <= moonId; i++) orbits[i].visible = true;
	else for (let i = mercuryId; i <= moonId; i++) orbits[i].visible = false;
});

// Listener for incline/not incline orbits
$("#orbitInclinationCheckbox").on("change", function(event) {
	if (event.target.checked) {
		inclinedOrbit = true;
		for (let i = mercuryId; i <= moonId; i++) orbits[i].rotation.y = THREE.Math.degToRad(data[i].orbitInclination);
	}
	else {
		inclinedOrbit = false;
		for (let i = mercuryId; i <= moonId; i++) orbits[i].rotation.y = 0;
	}
});
\end{lstlisting}
\paragraph{Earth Clouds setting}\mbox{}\\
With this checkbox, it is possible to show or hide the Earth clouds simply:
\begin{lstlisting}
// Listener for show/hide Earth clouds
$("#earthCloudCheckbox").on("change", function(event) {
	if (event.target.checked) celestialObjects[earthId].add(celestialObjects[earthCloudId]);
	else celestialObjects[earthId].remove(celestialObjects[earthCloudId]);
});
\end{lstlisting}
\paragraph{Asteroid Belt setting}\mbox{}\\
As previous, it permits to show or hide the Asteroid Belt:
\begin{lstlisting}
// Listener for show/hide asteroid belt
$("#asteroidBeltCheckbox").on("change", function(event) {
	if (event.target.checked) celestialObjects[solarSystemId].add(celestialObjects[asteroidBeltId]);
	else celestialObjects[solarSystemId].remove(celestialObjects[asteroidBeltId]);
});
\end{lstlisting}
\paragraph{Asteroid Belt setting}\mbox{}\\
This selector permits to change the background wallpaper used in the simulator. It changes the texture of the faces of the cube in which the simulator is enclosed:
\begin{lstlisting}
// Listener for modify background
$("#backgroundSelect").on("change", function(event) {
	let background = $("#backgroundSelect").val();
	scene.background = backgrounds[background];
});
\end{lstlisting}

\subsubsection{Mouse interactions}
These features allow you to focus the camera of the scene on the object on which you interact with the mouse. These functionalities exploit the use of the \textit{ray caster}\cite{documentation:threejs} that allows to trace all the objects that are under the mouse. Both are based on the use of the same \textit{captureObject} function that takes as input eventually the object in which save the mouse coordinates. Here illustrated below:
\begin{lstlisting}
function captureObject(point) {
	// Normalize mouse coordinates
	mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
	mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
	
	// Capture the clicked object
	raycaster.setFromCamera(mouse, camera);
	var intersects = raycaster.intersectObjects(scene.children, true);
	
	// Analize the result
	for (let i = 0; i < intersects.length; i++)
	if (intersects[i].object.name != "orbit" && intersects[i].object.name != "Sun Glow") {
		if ($("#asteroidBeltCheckbox").is(":checked")) {
			if (point) point.coord = intersects[i].point; // Funct called by showInfoPlanet
			return intersects[i].object; // Found object that is not an orbit or sun glow
		}
		else {
			if (intersects[i].object.name != "Asteroid Belt") {
				if (point) point.coord = intersects[i].point; // Funct called by showInfoPlanet
				return intersects[i].object; // Found object that is not an orbit, sun glow or asteroid belt
			}
		}
	}
	return null; // There are no element or only orbits
}
\end{lstlisting}
\par In the first step, we convert the pixel coordinates of mouse event in universal coordinate. These are coordinates where the we have in x-axis and in y-axis values between [-1,1], because the mouse events trigger a coordinate represented by the pixel position and we are not interested in it.\\
So, after obtaining the coordinates, we call the \textit{ray caster} such that it takes objects from camera and scene using the mouse position.\\
The result is an array of the intersected objects. Purpose is to visit the array to look for the first useful celestial object. To do this, however, we ignore the sun glow and the trajectories of the orbits that we are not interested in. Also, if the asteroid band has been deactivated, then we ignore that too. Finally we return the first useful object found.\\
The found object is used in the next features.
\paragraph{Double click feature}\mbox{}\\
This feature consists in targeting the celestial object on which the user has double-clicked. In order to detect the target object we use the previous function, then it returns the found target and we work with it.\\
Here the function that performs this task:
\begin{lstlisting}
function dblclickPlanet(event) {
	// Capture the object
	var targetElement = captureObject(null); // Null if it's not object or it's orbit or sun glow
	
	// Focus camera on it
	if (targetElement && targetElement.name != celestialObjects[asteroidBeltId].name && targetElement.name != celestialObjects[moonId].name) {
		followPlanetId = targetElement.myId;
		if (data[followPlanetId].hasOwnProperty("groupId")) followPlanetId = data[followPlanetId].groupId;
		followPlanet(followPlanetId);
		goToObject(followPlanetId);
		$("#cameraSelect").val(targetElement.myId);
		$("#cameraSelect").formSelect();
	}
}
\end{lstlisting}
In the first step we call the previous function passing as parameter \textit{null} because we are not interested on the mouse coordinates.\\
Then if the target is not null and is not asteroid belt, the function calls \textit{followPlanet} that set the object as new target and \textit{goToObject}, instead, moves the camera near the object. Finally change the current value of selector in the menu.
\paragraph{Mouse on an object}\mbox{}\\
This feature is triggered when the mouse cursor is on a planet or other objects. The scope is the showing of an information panel containing some physical feature of the planet highlighted. It is realized with the dedicated function:
\begin{lstlisting}
function showInfoPlanet(event) {
	// Capture the object
	var point = {coord:null};
	var targetElement = captureObject(point); // Null if it's not object or it's orbit or sun glow
	
	// Show tooltip
	if (targetElement) {
		$("#tooltip").css({
			display: "block",
			opacity: 0.0
		});
		tooltipping = true;
		var canvasHalfWidth = renderer.domElement.offsetWidth / 2;
		var canvasHalfHeight = renderer.domElement.offsetHeight / 2;
		
		var tooltipPosition = point.coord.clone().project(camera);
		tooltipPosition.x = (tooltipPosition.x * canvasHalfWidth) + canvasHalfWidth + renderer.domElement.offsetLeft;
		tooltipPosition.y = -(tooltipPosition.y * canvasHalfHeight) + canvasHalfHeight + renderer.domElement.offsetTop;
		
		var tootipWidth = $("#tooltip")[0].offsetWidth;
		var tootipHeight = $("#tooltip")[0].offsetHeight;
		
		$("#tooltip").css({
			left: `${tooltipPosition.x - tootipWidth/2}px`,
			top: `${tooltipPosition.y - tootipHeight - 70}px`
		});
		
		let currentId = targetElement.myId;
		
		$("#tooltip").html("<div style='float:left;padding-top:10px;padding-left:10px;'><img src='" + data[currentId].icon + "' width=50></div> <h4 style='size:20pt;'>" + targetElement.name + "</h4>");
		if(data[currentId].hasOwnProperty("rotationRate")) $("#tooltip").append("</br>Rotation: " + data[currentId].rotationRate.toFixed(2) + " hours");
		
		//...and other features
		
		setTimeout(function() {
			$("#tooltip").css({
				opacity: 1.0
			});
		}, 25);
	}
	else {
		$("#tooltip").css({
			display: "none"
		});
		tooltipping = false;
	}
}
\end{lstlisting}
On the contrary of the previous paragraph, in this case we call the function passing as parameter an object that we use to save the coordinate of the mouse cursor, because we use this coordinate to build the panel near to it.\\
So, after detected the object, function builds the panel and starts to add all the available information. Finally we set a timeout to appear the panel.


\subsection{HTML and CSS Frontend}
We decide to build the frontend using HTML and CSS because of WebGL is a language, born for internet browser and then HTML is the ideal to make the user interface.
\subsubsection{Libraries}
First of all we need to load the needed libraries. This is done in the body, as loading takes place more quickly. Moreover, we load the css files in the head tag.
\subsubsection{Loading Page}
The first page that appears when user executes our project is the loading page. We decide to implement it to avoid to show a simply black page to him since sometimes application can take some seconds before of show it.\\
In order to implement this page, we take inspiration from some example in the web\cite{loadingpage:web}.
\begin{lstlisting}
$(window).on("load", function() {
	$("#loading").css("display", "none"); // Hide chargement
	render(); // Render starts when window has been loaded
});
\end{lstlisting}
This function simply hide the loader element when event "load" is triggered.
\subsubsection{Sidebar menu}
One of the most important things in the HTML file is the sidebar menu, done with the help of the \textit{Materialize}\cite{materialize} library. All functions in the menu have been described above.

\subsubsection{Tooltip}
It's simply a div that allows you to view information about celestial objects when the mouse hovers them. To do this, it is initialized with the display attribute set to none. When the mouse hovers the object, that attribute is set to block to make it visible, and inside it is put the text to show. In the CSS file the style has been changed to make it consistent with the style used until now.

\subsubsection{Date}
We have inserted another div that allows you to view the current date and time. Initially they were user modifiable, but that was problematic. That's why we decided to make it only readable and included the possibility to change the date and time in the menu.

\subsubsection{Container}
At the end we have a simple div tag, whose function is to contain our solar system.

\begin{thebibliography}{99}
\bibitem{solarsystemrealpositon} \href{https://theskylive.com/3dsolarsystem}{Verify} the real-time position of solar system objects.
\bibitem{planetpixelemporium} \href{http://planetpixelemporium.com/planets.html}{Planet pixel emporium}, website for planet textures.
\bibitem{wikipedia} \href{https://www.wikipedia.org/}{Wikipedia} - for data and descriptions of the celestial objects.
\bibitem{earthcloudsradiustexture:github} \href{https://github.com/jeromeetienne/threex.planets/blob/master/threex.planets.js}{Threex.planets.js} - for loading earth clouds texture and have a ring geometry with a radius texture.
\bibitem{documentation:threejs} ThreeJS documentation: \href{https://threejs.org/docs/#api/en/scenes/Scene}{Scene}
\href{https://threejs.org/docs/#api/en/cameras/PerspectiveCamera}{Perspective Camera}  \href{https://threejs.org/docs/#examples/en/controls/OrbitControls}{OrbitControls} \href{https://threejs.org/docs/#api/en/core/Raycaster}{Raycaster} \href{https://threejs.org/docs/#api/en/renderers/WebGLRenderer}{WebGLRenderer}.
\href{https://threejs.org/docs/#api/en/loaders/TextureLoader}{Texture Loader}
\href{https://threejs.org/docs/#api/en/lights/PointLight}{Point Light}
\href{https://threejs.org/docs/#api/en/lights/AmbientLight}{Ambient Light}
\href{https://threejs.org/docs/#api/en/audio/AudioListener}{Audio Listener}
\href{https://threejs.org/docs/#api/en/audio/Audio}{Audio}
\href{https://threejs.org/docs/#api/en/geometries/SphereGeometry}{Sphere Geometry}
\href{https://threejs.org/docs/#api/en/materials/MeshPhongMaterial}{MeshPhongMaterial}
\href{https://threejs.org/docs/#api/en/materials/SpriteMaterial}{Sprite Material}
\href{https://threejs.org/docs/#api/en/objects/Sprite}{Sprite}
\href{https://threejs.org/docs/#api/en/geometries/CircleGeometry}{Circle Geometry}
\href{https://threejs.org/docs/#api/en/materials/LineBasicMaterial}{Line Basic Material}
\href{https://threejs.org/docs/#api/en/objects/LineLoop}{Line Loop}
\href{https://threejs.org/docs/#api/en/objects/Points}{Points}
\href{https://threejs.org/docs/#api/en/geometries/TorusGeometry}{Torus Geometry}
\href{https://threejs.org/docs/#api/en/materials/PointsMaterial}{Points Material}
\href{https://threejs.org/docs/#api/en/geometries/RingGeometry}{Ring Geometry}
\href{https://threejs.org/docs/#api/en/core/Raycaster}{Raycaster}
\bibitem{PCSS:nvidia} \href{http://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf}{Percentage-Closer Soft Shadows}, Randima Fernando, NVIDIA Corporation.
\bibitem{solarcore:wikipedia}
\href{https://en.wikipedia.org/wiki/Solar_core#Energy_conversion}{Solar core}, Wikipedia article.
\bibitem{trajectory:stackoverflow}
\href{https://stackoverflow.com/questions/13756112/draw-a-circle-not-shaded-with-three-js}{Draw} a circle (not shaded) using Three.js.
\bibitem{asteroids:stackoverflow}
\href{https://stackoverflow.com/questions/56870759/typeerror-cant-convert-undefined-to-object-in-three-js-using-three-points/}{TypeError} Stack Overflow question.
\bibitem{resizing:stackoverflow}
\href{https://stackoverflow.com/questions/20290402/three-js-resizing-canvas}{Three.js} resizing canvas.
\bibitem{loadingpage:web}
\href{http://www.diplod.it/2014/01/13/javascript-per-pagina-in-caricamento-loading-con-eleganza/}{Example} of loading page
\bibitem{materialize} \href{https://materializecss.com/}{Materialize}
\end{thebibliography}



\end{document}